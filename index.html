<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/grid.css">
    <script defer src="script.js"></script>
    <title>Document</title>
</head>
<body>
    <header class="header" id="header">
        <div class="header-container">
            <p class="title">Теория графов</p>
            <ul class="header-menu">
                <li><a id="what-is-graph" href="" onclick="return false;">Что такое граф</a></li>
                <li><a id="vidi-graphs" href="" onclick="return false;">Виды графов</a></li>
                <li><a id="algotithms" href="" onclick="return false;">Алгоритмы на графах</a></li>
                <li><a id="problems" href="" onclick="return false;">Задачи</a></li>
            </ul>
        </div>
    </header>
    <main>
        <div class="main-container">
            <h1>Теория графов</h1>
            <h2 id="what-is-graph-h2">Что такое граф</h2>
                <p>Граф — это математическая структура, которая используется для моделирования связей между различными объектами. Граф состоит из:
вершин — ключевые точки или объекты в графе. Это могут быть, например, города на карте, веб-страницы в интернете или отделы в компании; и рёбер — линии, которые соединяют вершины. Например, дорога между двумя городами, гиперссылка между веб-страницами или взаимодействие между отделами в компании.</p>
                <p>С помощью графов хорошо получается изображать сложные связи, для которых не подходят другие способы визуализации. Например, с помощью графа можно показать карту социальных связей человека, в которой вершинами будут люди, а рёбрами — взаимоотношения.</p>
                <p>Ребро, соединяющее одну вершину с другой, называется инцидентным этим вершинам. Например, ребро AB соединяет вершины A и B. Оно будет инцидентно как вершине A, так и вершине B. Отношение инцидентности существует только между вершиной и ребром, два ребра или две вершины не могут быть инцидентными.</p>
                <p>Рёбра могут быть направленными и ненаправленными. Если вершины A и B соединяет ребро и из A можно попасть в B и обратно, то ребро будет ненаправленным. Например, дорога, соединяющая города A и B, по которой можно попасть как из A и B, так и из B в A, — это ненаправленное ребро между вершинами графа A и B.</p>
            <h2 id="vidi-graphs-h2">Виды графов</h2>
                <p>Существует множество видов графов, каждый из которых полезен для отображения определённых типов связи между объектами.</p>
                <p>Ориентированные, неориентированные и смешанные графы:</p>
                <ul>
                    <li>Ориентированный. Граф, в котором каждое ребро указывает своё направление с помощью стрелок, по которым можно передвигаться. Например, когда есть путь A → B → C, но нет обратных рёбер; вернуться из C в A нельзя.</li>
                    <li>Неориентированный. Граф, в котором рёбра не указывают направление. Это значит, что из любой вершины можно попасть в любую точку графа.</li>
                    <li>Смешанный. Граф, который содержит как ориентированные, так и неориентированные рёбра.</li>
                
                </ul>
                <p>Графы с петлями и мультиграфы:</p>
                <ul>
                    <li>Граф с петлями. Рёбра графа, которые начинаются и заканчиваются в одной и той же вершине, называются петлями. Например, если мы строим схему связей в социальной сети, то с помощью петли можно показать, что пользователь ставит лайки своим же публикациям.</li>
                    <li>Мультиграф. Если между двумя графами существует несколько рёбер, то такой граф будет называться мультиграфом. Такие графы часто используются в схемах транспортных систем, когда между городами есть несколько разных маршрутов (железная дорога, автомобильная дорога и авиарейсы).</li>

                </ul>
                <p>Пустые и полные графы:</p>
                <ul>
                    <li>Пустой граф. Тип графа, который не содержит рёбер. У него могут быть вершины, но между этими вершинами нет никаких связей. Так можно показать системы, в которых есть объекты, не взаимодействующие с другими объектами. Например, в схеме социальных связей так можно изобразить человека, который ни с кем не общается.</li>
                    <li>Полный граф. Граф, в котором каждая вершина соединена ребром с каждой другой вершиной. Так можно показать коллектив, в котором все знают друг друга.</li>
                </ul>
                <p>Связный граф:</p>
                <p>Связный граф — граф, в котором существует путь между любой парой вершин. Из каждой вершины по рёбрам можно добраться до любой другой вершины. В связном графе нет изолированных вершин или групп, которые не связаны с остальными частями графа.</p>
                <p>Взвешенный граф:</p>
                <p>Взвешенный граф — граф, в котором каждому ребру присвоено числовое значение — вес. Это может быть расстояние, время, стоимость, мощность или другая характеристика, связанная с соединением вершин.</p>
            <h2 id="algotithms-h2">Алгоритмы на графах</h2>
                <h3>Поиск в глубину</h3>
                <p>Поиск в глубину (англ. Depth-first search, DFS) — один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно. Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить алгоритм от одной из нерассмотренных вершин.</p>
                <p>Временная сложность алгоритма поиска в глубину — O(V + E), где V — количество вершин, а E — количество рёбер. Пространственная сложность алгоритма равна O(V), где V — количество вершин.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/new_dfs.gif">
                    <p id="m1-text" class="text-image">Порядок обхода графа в глубину</p>
                </div>
                <h3>Поиск в ширину</h3>
                <p>Поиск в ширину (англ. breadth-first search, BFS) — один из методов обхода графа. Пусть задан граф G=(V, E) и выделена исходная вершина s. Алгоритм поиска в ширину систематически обходит все ребра G для «открытия» всех вершин, достижимых из s, вычисляя при этом расстояние (минимальное количество рёбер) от s до каждой достижимой из s вершины. Алгоритм работает как для ориентированных, так и для неориентированных графов.</p>
                <p>Поиск в ширину имеет такое название потому, что в процессе обхода мы идём вширь, то есть перед тем как приступить к поиску вершин на расстоянии k+1, выполняется обход вершин на расстоянии k.</p>
                <p>Временная сложность алгоритма поиска в ширину— O(V + E), где V — количество вершин, а E — количество рёбер. Пространственная сложность алгоритма равна O(V), где V — количество вершин.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/new_bfs.gif">
                    <p id="m1-text" class="text-image">Порядок обхода графа в ширину</p>
                </div> 
                <h3>Алгоритм Дейкстры</h3>
                <p>Алгоритм Дейкстры (англ. Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса. Алгоритм широко применяется в программировании, например, его используют протоколы маршрутизации OSPF и IS-IS.</p>
                <p>Алгоритм Дейкстры используют для решения «задачи о кратчайших путях с единственным источником». Она заключается в поиске кратчайших путей от заданной вершины до всех остальных во взвешенном графе с неотрицательными весами.</p>
                <p>Введём следующие обозначения:</p>
                <ul>
                    <li>n — количество вершин в графе</li>
                    <li>m — количество ребер в графе</li>
                    <li>s — стартовая вершина</li>
                    <li>d — массив расстояний</li>
                    <li>p — массив предков каждой вершины графа</li>
                </ul>
                <p>Алгоритм Дейкстры выполняется за n итераций. На каждой итерации выбирается вершина v с минимальным значением d[v] среди непомеченных вершин. Эта вершина v затем отмечается как помеченная. Далее на текущей итерации происходит этап релаксации. В этом этапе просматриваются все ребра (v, to), исходящие из вершины v, и проверяется, можно ли улучшить значение d[to]. То есть, если длина рассматриваемого ребра равна l, тогда d[to] = min(d[to], d[v] + l). При успешной релаксации, то есть когда удалось улучшить расстояние до вершины to, в массиве p указывается, что предшественником на кратчайшем пути к вершине to является вершина v, то есть p[to] = v. На этом итерация заканчивается.</p>
                <p>По завершении n итераций все вершины графа оказываются помеченными, и алгоритм заканчивает выполнение.</p>
                <p>Важно заметить, что если из начальной вершины s невозможно построить путь до некоторых вершин графа, их значения d[v] останутся бесконечными. Алгоритм можно завершить досрочно, как только будет выбрана вершина с бесконечным значением расстояния.</p>
                <p>Рассмотрим работу алгоритма на примере. Будем искать кратчайшие пути от вершины 4.</p>
                <p>Изначально массивы u (посещений), d (расстояния) и p (предков) для графа из примера имеют следующие значения:</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-1.webp">
                    <p id="m1-text" class="text-image">Изначальные значения</p>
                </div>
                <p>На первой итерации мы выбираем вершину v с наименьшим значением d[v]. Очевидно, что на первом шаге будет выбрана стартовая вершина — 4.</p>
                <p>Помечаем её посещённой u[4] = true.</p>
                <p>Дальше проходим по всем соседям вершины 4 и пытаемся улучшить для них значения в массиве d. Для всех вершин, расстояние до которых удалось улучшить, в список предков записываем вершину 4. На первой итерации удалось улучшить расстояния до вершин 1, 5, 6. В результате значения массивов u, d, p изменились следующим образом: </p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-2.webp">
                    <p id="m1-text" class="text-image">После первой итерации</p>
                </div>
                <p>На следующем шаге выбираем вершину 6. Улучшаем расстояния до вершин 3 и 7.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-3.webp">
                    <p id="m1-text" class="text-image">После второй итерации</p>
                </div>
                <p>Следующая непосещённая вершина с минимальным весом — 1.</p>
                <p>Расстояние от вершины 4 до вершины 1 равняется 3. Пытаемся улучшить расстояние до всех её соседей. Так, например, можно улучшить расстояние до вершины 5. Ранее оно было равно 8, а после релаксации это значение уменьшается:</p>
                <p>d[5] = min(d[5], d[1] + l) = min(8, 3 + 2) = 5.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-4.webp">
                    <p id="m1-text" class="text-image">После третьей итерации</p>
                </div>
                <p>И аналогичным образом мы проходим все оставшиеся итерации.</p>
                <p>Выбираем непосещённую вершину с минимальным значением d[v]. На этой итерации будет выбрана вершина 7. Ни для одного её соседа длину кратчайшего пути улучшить не удалось.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-5.webp">
                    <p id="m1-text" class="text-image">После четвёртой итерации</p>
                </div>
                <p>На следующей итерации будет посещена вершина 2. От неё удалось улучшить путь до вершин 0 и 3.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-6.webp">
                    <p id="m1-text" class="text-image">После пятой итерации</p>
                </div>
                <p>Далее посетив вершину 5 улучшаем путь до вершины 8.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-7.webp">
                    <p id="m1-text" class="text-image">После шестой итерации</p>
                </div>
                <p>На последующих итерациях помечаются посещёнными вершины 8, 0 и 3. От них нельзя улучшить путь ни до одного из их соседей.</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-8.webp">
                    <p id="m1-text" class="text-image">После седьмой итерации</p>
                </div>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-9.webp">
                    <p id="m1-text" class="text-image">После восьмой итерации</p>
                </div>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-10.webp">
                    <p id="m1-text" class="text-image">После девятой итерации</p>
                </div>
                <p>После окончания работы алгоритма значения массивов u, d, p:</p>
                <div id="m1-div">
                    <img id="m1-img" src="img/Dijkstra-11.webp">
                    <p id="m1-text" class="text-image">После десятой итерации</p>
                </div>
            <h2 id="problems-h2">Задачи</h2>
                <h3>Задача №1</h3>
                <p>В клубе N человек. Многие из них - друзья. Так же известно, что друзья друзей так же являются друзьями. Требуется выяснить, сколько всего друзей у конкретного человека в клубе.</p>
                <h4>Входные данные:</h4>
                <p>В первой строке заданы два числа: N и S (1 ≤ N ≤ 100; 1 ≤ S ≤ N), где N - количество человек в клубе, а S – номер конкретного человека. В следующих N строках записано по N чисел - матрица смежности, состоящая из единиц и нулей. Причем единица, стоящая в i-й строке и j-м столбце гарантирует, что люди с номерами i и j – друзья, а 0 – выражает неопределенность.</p>
                <h4>Выходные данные:</h4>
                <P>Выведите количество гарантированных друзей у человека с номером S, помня о транзитивности дружбы.</P>
                <h4>Пример:</h4>
                <table>
                    <tr>
                        <td>Входные данные</td>
                        <td>Выходные данные</td>
                    </tr>
                    <tr>
                        <td><pre>3 1
0 1 0
1 0 1
0 1 0</pre></td>
                        <td>2</td>
                    </tr>
                </table>
                <details>
                    <summary>Решение</summary>
                    <p>Решение на алгоритмическом языке:</p>
                    <p><pre>//обход в глубину графа из вершины v с пометкой этой вершины
  void dfs(v){
    k=k+1;      //увеличиваем счетчик
    b[v]=true;  //помечаем "друга"
    for i=1..n
      if(a[v][i]=1 and b[i]=false) dfs(i);
  }
  //чтение входных данных
  read(n,s);
  for i=1..n
    for j=1..n
      read(a[i][j]);
 
  k=-1;   //обнуление счетчика с учетом того, что самого себя считать другом не следует
  dfs(s);
  write(k);</pre></p>
                </details>
            <h3>Задача №2</h3>
            <p>Дан ориентированный взвешенный граф. Для него вам необходимо найти кратчайшее расстояние от вершины S до вершины F.</p>
            <h4>Входные данные:</h4>
            <p>В первой строке записаны три числа: N, S и F (1 ≤ N ≤ 100; 1 ≤ S, F ≤ N), где N - количество вершин графа. В следующих N строках записаны по N чисел - матрица смежности графа, где число в i-ой строке j-ом столбце соответствует ребру из i в j: -1 означает отсутствие ребра между вершинами, а любое неотрицательное целое число (от 0 до 100) - наличие ребра данного веса. На главной диагонали матрицы всегда записаны нули.</p>
            <h4>Выходные данные:</h4>
            <p>Необходимо вывести искомое расстояние или -1, если пути между указанными вершинами не существует.</p>
            <h4>Пример:</h4>
            <table>
                <tr>
                    <td>Входные данные</td>
                    <td>Выходные данные</td>
                </tr>
                <tr>
                    <td><pre>3 2 1
0 1 1
4 0 1
2 1 0</pre></td>
                    <td>3</td>
                </tr>
            </table>
            <details>
                <summary>Решение</summary>
                <p>Решение на языке Python:</p>
                <p><pre>n, s, f = map(int, input().split())
s, f = s-1, f-1
arr = []
p = [1e10]*n
p[s] = 0
q = [s]
for i in range(n):
	arr.append(list(map(int, input().split())))
while len(q) > 0:
	for i in range(n):
		if arr[q[0]][i] != -1 and arr[q[0]][i]+p[q[0]] < p[i]:
			q.append(i)
			p[i] = arr[q[0]][i]+p[q[0]]
	q.pop(0)
if p[f] == 1e10:
	print(-1)
else:
	print(p[f])</pre></p>
            </details>
            <h3>Задача №3</h3>
            <p>В подземелье M тоннелей и N перекрестков, каждый тоннель соединяет какие-то два перекрестка. Мышиный король решил поставить по светофору в каждом тоннеле перед каждым перекрестком. Напишите программу, которая посчитает, сколько светофоров должно быть установлено на каждом из перекрестков. Перекрестки пронумерованы числами от 1 до N.</p>
            <h4>Входные данные</h4>
            <p>В первой строке записано два числа N и M (0 < N ≤ 100, 0 ≤ M ≤ N*(N-1)/2). В следующих M строках записаны по два числа i и j (1 ≤ i,j ≤ N), которые означают, что перекрестки i и j соединены тоннелем. Можно считать, что любые два перекрестка соединены не более, чем одним тоннелем. Нет тоннелей от перекрестка i до него самого.</p>
            <h4>Выходные данные</h4>
            <p>Вывести N чисел: k-ое число означает количество светофоров на k-ом перекрестке.</p>
            <table>
                <tr>
                    <td>Входные данные</td>
                    <td>Выходные данные</td>
                </tr>
                <tr>
                    <td><pre>7 10
5 1
3 2
7 1
5 2
7 4
6 5
6 4
7 5
2 1
5 3
</pre></td>
                    <td>3 3 2 2 5 2 3</td>
                </tr>
            </table>
            <details>
                <summary>Решение</summary>
                <p>Решение на языке C++</p>
                <p><pre>#include &ltiostream&gt
#include &ltvector&gt
 
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> v(n);
    for(int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        a--;b--;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    for(int i = 0; i < n; i++) {
        cout << v[i].size() << " ";
    }
    return 0;
}</pre></p>
            </details>
        </div>
        <a class="strelka-hidden" href="" onclick="return false;"><img src="img/strelka.svg" id="strelka-img"></a>
    </main>
<body>
</html>
